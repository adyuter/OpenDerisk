"""Auto reasoning_engine chat manager agent."""

import json
import logging
from enum import Enum
from typing import Dict, List, Optional
from derisk._private.pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    model_to_dict,
    validator,
)
from ....resource.base import AgentResource
from ...base_agent import (
    Agent,
    AgentMessage,
    ActionOutput,
    ConversableAgent,
    ProfileConfig,
)
from ...base_team import ManagerAgent
from ...memory.gpts import GptsPlan
from derisk.core import ModelMessageRoleType
from derisk.util.configure import DynConfig
from .planner_agent import ReActPlannerAgent

logger = logging.getLogger(__name__)


class AutoTeamContext(BaseModel):
    teamleader: Optional[str] = Field(
        None,
        description="The multi agents teamleader",
        examples=[
            "advance_planning",
            "dynamic_planning",
        ],
    )
    can_ask_user: Optional[bool] = Field(
        True,
        description="Can ask user",
        examples=[
            True,
            False,
        ],
    )
    llm_strategy: Optional[str] = Field(
        None, description="The team leader's llm strategy"
    )
    llm_strategy_value: Optional[str] = Field(
        None, description="The team leader's llm config"
    )
    prompt_template: Optional[str] = Field(
        None, description="The team leader's prompt template!"
    )
    resources: Optional[list[AgentResource]] = Field(
        None, description="The team leader's prompt template!"
    )

    def to_dict(self):
        return model_to_dict(self)


class ReActPlanChatManager(ManagerAgent):
    """A chat manager agent that can manage a team chat of multiple agents."""

    profile: ProfileConfig = ProfileConfig(
        name=DynConfig(
            "ReAct Manager",
            category="agent",
            key="derisk_agent_plan_team_react_plan_profile_name",
        ),
        role=DynConfig(
            "ReActManager",
            category="agent",
            key="derisk_agent_plan_team_react_plan_profile_role",
        ),
        goal=DynConfig(
            "Advance the task reasoning_engine generated by the planning agent. If the reasoning_engine "
            "does not pre-allocate an agent, it needs to be coordinated with the "
            "appropriate agent to complete.",
            category="agent",
            key="derisk_agent_plan_team_auto_plan_profile_goal",
        ),
        desc=DynConfig(
            "Advance the task reasoning_engine generated by the planning agent.",
            category="agent",
            key="derisk_agent_plan_team_auto_plan_profile_desc",
        ),
    )
    concurrency_limit: int = 6

    def __init__(self, **kwargs):
        """Create a new AutoPlanChatManager instance."""
        super().__init__(**kwargs)

    async def process_rely_message(
        self, conv_id: str, now_plan: GptsPlan, speaker: Agent
    ):
        """Process the dependent message."""
        rely_prompt = None
        rely_messages: List[Dict] = []

        if now_plan.rely and len(now_plan.rely) > 0:
            rely_tasks_list = now_plan.rely.split(",")
            rely_tasks_list_int = [int(i) for i in rely_tasks_list]
            rely_tasks = self.memory.plans_memory.get_by_conv_id_and_num(
                conv_id, rely_tasks_list_int
            )
            if rely_tasks:
                rely_prompt = (
                    "Read the result data of the dependent steps in the above"
                    " historical message to complete the current goal:"
                )
                for rely_task in rely_tasks:
                    rely_messages.append(
                        {
                            "content": rely_task.sub_task_content,
                            "role": ModelMessageRoleType.HUMAN,
                            "name": rely_task.sub_task_agent,
                        }
                    )
                    rely_messages.append(
                        {
                            "content": rely_task.result,
                            "role": ModelMessageRoleType.AI,
                            "name": rely_task.sub_task_agent,
                        }
                    )
        return rely_prompt, rely_messages

    async def act(
        self,
        message: Optional[AgentMessage],
        sender: Optional[Agent] = None,
        reviewer: Optional[Agent] = None,
        **kwargs,
    ) -> Optional[ActionOutput]:
        """Perform an action based on the received message."""
        if not sender:
            return ActionOutput(
                is_exe_success=False,
                content="The sender cannot be empty!",
            )

        try:
            message_rounds = message.rounds
            last_round_messages: List = []
            first_plan_conv = []
            all_task_messages: List = []
            all_messages: List = []
            for i in range(self.max_round):
                if not self.memory:
                    return ActionOutput(
                        is_exe_success=False,
                        content="The memory cannot be empty!",
                    )

                ## 读取新的背景知识

                ## 读取历史消息进展

                ## 规划新的任务步骤
                planner: ConversableAgent = (
                    await ReActPlannerAgent()
                    .bind(self.memory)
                    .bind(self.agent_context)
                    .bind(self.bind_prompt)
                    .bind(self.llm_config)
                    .bind_agents(self.agents)
                    .build()
                )

                rely_messages = last_round_messages.copy()
                if i > 1:
                    rely_messages = first_plan_conv + rely_messages
                last_round_messages.clear()
                if i == 0:
                    plan_input = f"根据用户输入:{message.content}分析初始路径"
                    message_rounds = message_rounds + 1
                    plan_in_message = AgentMessage.from_llm_message(
                        {"content": plan_input, "rounds": message_rounds}
                    )

                    first_plan_conv.append(plan_in_message)

                    await self.send(
                        message=plan_in_message, recipient=planner, request_reply=False
                    )

                    plan_message = await planner.generate_reply(
                        received_message=plan_in_message,
                        sender=self,
                        reviewer=reviewer,
                    )
                    first_plan_conv.append(plan_message)

                else:
                    plan_input = (
                        "请根据历史对话消息的进展和经验寻找进一步可行的方法和路径"
                    )
                    message_rounds = message_rounds + 1
                    plan_in_message = AgentMessage.from_llm_message(
                        {"content": plan_input, "rounds": message_rounds}
                    )

                    await self.send(
                        message=plan_in_message, recipient=planner, request_reply=False
                    )

                    plan_message = await planner.generate_reply(
                        received_message=plan_in_message,
                        sender=self,
                        reviewer=reviewer,
                        historical_dialogues=all_messages,
                    )

                last_round_messages.append(plan_in_message)
                all_messages.append(plan_in_message)
                await planner.send(
                    message=plan_message, recipient=self, request_reply=False
                )
                last_round_messages.append(plan_message)
                all_messages.append(plan_message)

                task_params = json.loads(plan_message.action_report.content)

                ## 执行新的任务步骤(排除需要用户代理处理的任务)
                api_tasks = []
                from derisk.agent import get_agent_manager

                agent_manager = get_agent_manager()
                ask_user = None
                agent_role_map = {agent.name: agent for agent in self.agents}
                role_goal_map = {}
                for task in task_params:
                    agent_name = task.get("agent")
                    agent_goal = task.get("task_goal")
                    if agent_name == "Human":
                        ask_user = agent_goal
                        continue

                    if not agent_name:
                        raise

                    task_agent: ConversableAgent = agent_role_map.get(agent_name)
                    if not task_agent:
                        logger.warning(f"agent{agent_name}没有找到具体agent！")
                        continue
                    agent_role_map.update({task_agent.role: task_agent})

                    task_input = f"任务目标:{agent_goal},相关参数:{json.dumps(task.get('slots'))}"
                    message_rounds = message_rounds + 1
                    task_in_message = AgentMessage.from_llm_message(
                        {"content": task_input, "rounds": message_rounds}
                    )
                    role_goal_map.update({task_agent.role: task_in_message})
                    if task_agent.role == "final_report_agent":
                        api_tasks.append(
                            task_agent.generate_reply(
                                received_message=task_in_message,
                                sender=self,
                                reviewer=reviewer,
                                rely_messages=None,  # 会变成单论消息
                                historical_dialogues=all_task_messages,  # 会变成多轮历史消息
                            )
                        )

                    else:
                        api_tasks.append(
                            task_agent.generate_reply(
                                received_message=task_in_message,
                                sender=self,
                                reviewer=reviewer,
                            )
                        )

                from derisk.util.chat_util import run_async_tasks

                results: List[AgentMessage] = await run_async_tasks(
                    tasks=api_tasks, concurrency_limit=self.concurrency_limit
                )

                ## 检察所有计划任务输出，有效输出记录消息
                for result in results:
                    task_agent = agent_role_map.get(result.role)
                    ## 判断消息结果
                    if result.role == "final_report_agent":
                        ## 处理终止代理任务，结束对话，告诉用户结论
                        return result.action_report
                    else:
                        ## 如果没有用户任务，重新进入下一个阶段直到出现终止任务的Agent

                        task_in_message = role_goal_map.get(result.role)
                        logger.info(f"消息发送给:{task_agent},{result.role},{result}")
                        if task_agent:
                            await self.send(
                                message=task_in_message,
                                recipient=task_agent,
                                request_reply=False,
                            )
                            last_round_messages.append(task_in_message)
                            all_task_messages.append(task_in_message)
                            all_messages.append(task_in_message)
                            await task_agent.send(
                                message=result, recipient=self, request_reply=False
                            )
                            all_task_messages.append(result)
                            last_round_messages.append(result)
                            all_messages.append(result)

                ## 处理用户代理任务，终断循环，进入用户交互
                if ask_user:
                    return ActionOutput(is_exe_success=True, content=ask_user)
        except Exception as e:
            logger.exception("ReAct Team Chat Exception！")
            return ActionOutput(is_exe_success=False, content=str(e))
